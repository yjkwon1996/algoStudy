# 사다리 조작. 사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다.
# 인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다.
# 초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다.
# 위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다.
# 사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.
# 위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다.
# 사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.
# 첫째 줄에 세로선의 개수 N, 가로선의 개수 M, 세로선마다 가로선을 놓을 수 있는 위치의 개수 H가 주어진다. (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)
# 둘째 줄부터 M개의 줄에는 가로선의 정보가 한 줄에 하나씩 주어진다.
# 가로선의 정보는 두 정수 a과 b로 나타낸다. (1 ≤ a ≤ H, 1 ≤ b ≤ N-1) b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결했다는 의미이다.
# 가장 위에 있는 점선의 번호는 1번이고, 아래로 내려갈 때마다 1이 증가한다. 세로선은 가장 왼쪽에 있는 것의 번호가 1번이고, 오른쪽으로 갈 때마다 1이 증가한다.
# 입력으로 주어지는 가로선이 서로 연속하는 경우는 없다.
# i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야 하는 가로선 개수의 최솟값을 출력한다. 만약, 정답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다.

import sys
input = sys.stdin.readline


N, M, H = map(int, input().rstrip().split())

line = [[False for _ in range(N)] for _ in range(H)]
for _ in range(M) :
    a, b = map(int, input().rstrip().split())
    line[a-1][b-1] = True

# i번 새로선의 결과가 i번이 되게 하려면?
# dfs 방식으로 가로선과 세로선을 탐색하면서 사다리를 놓을 수 있는 곳에 먼저 두고 재귀적으로 사다리를 두다가 문제 조건에 어긋나면 백트래킹

def dfs(x, y, cnt) :
    global answer

    # i번째 줄이 i번에 도착하는지 확인 - 모든 선을 체크하면됨.
    flag = True
    for i in range(N) : # 모든 선에 대하여 확인.
        now = i
        for j in range(H) :
            if line[j][now] : # 오른쪽에 가로선이 존재한다면
                now += 1 # 오른쪽으로 이동
            elif line[j][now-1] : # 왼쪽에 가로선이 존재한다면
                now -= 1 # 왼쪽으로 이동
        if now != i : # 처음 시작한 i번째 줄로 도착하지 않았다면 아직 i번째 줄이 i번에 도착하지 않는 경우
            flag = False

    # 다 체크했는데 flag가 True면 i번째 줄이 i번에 도착하는 경우.
    if flag :
        answer = min(answer, cnt) # 최소값으로 바꾸고 끝
        return
    elif cnt == 3 or answer <= cnt : # 횟수가 3이나 최소값을 넘어가도 더 탐색할 필요 없음
        return

    for i in range(x, H) :
        if i == x : # i번째 줄 그대로 가고 있다면
            now = y # 지금 탐색중인 곳부터
        else : # i번째 줄이 아니라면
            now = 0 # 처음부터 탐색

        for j in range(now, N-1) :
            if not line[i][j] and not line[i][j+1] : # 오른쪽에 가로선이 존재하지 않는 경우
                if j>0 and line[i][j-1] : # 왼쪽에 가로선이 있으면 스킵
                    continue
                line[i][j] = True # 가로선을 만들어서 dfs탐색하기
                dfs(i, j+2, cnt+1)
                line[i][j] = False # dfs탐색을 빠져나올 때, 만든 가로선을 다시 없애야 함

answer = sys.maxsize
dfs(0, 0, 0)

if answer == sys.maxsize :
    print(-1)
else :
    print(answer)






