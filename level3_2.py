
n = 6
s = 4
a = 6
b = 2
fares = [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]]

"""
n = 7
s = 3
a = 4
b = 1
fares = [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]]

n = 6
s = 4
a = 5
b = 6
fares = [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]]


"""


# 지점의 개수 n, 출발지점을 나타내는 s
# A의 도착지점 a, B의 도착지점 b
# 지점 사이의 예상 택시요금 fares 배열([x1와, y1의, 요금1], [x2와, y2의, 요금2])
# A, B 두사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 갈 때 최저 예상 택시요금
# 합승을 하지 않고 각자 이동하는 경우가 더 낮으면 합승 안해도 된다.
# 플루이드 - 와샬 알고리즘 이용
# 합승이 끝나는 지점 p -> 구해야 할 결과값 : 각 비용 s-p + p-a + p-b의 최소값
# s에서 모든 지점의 최소 비용, a에서 모든 지점의 최소비용, b에서 모든 지점의 최소 비용을 통해 계산
# n x n 그래프. 이동 방향에 따라 방향이 달라지지 않으므로 graph[start][end] = graph[end][start]
# 모든 지점에 대해 p에 대한 최소 비용을 구한다.
# p와 모든 지점에 대해서 s-p + p-a + p-b의 최소값을 찾으면 끝!

# 위와 비슷하게 거리 행렬을 만들고, 플루이드 - 와샬 알고리즘을
# 

from math import inf

# 인덱스가 0부터 시작. 계산의 편리를 위해
s, a, b = s-1, a-1, b-1

# 거리 행렬. 자기 자신으로 향하는 간선 가중치는 0
graph = [[inf] * n for _ in range(n)]
for i in range(n) : graph[i][i] = 0

# 거리 행렬에 주어진 비용 값을 넣는다.
for i, j, k in fares :
    graph[i-1][j-1] = graph[j-1][i-1] = k
    
# 플루이드 - 와샬 알고리즘
for k in range(n) : # 모든 노드를 중간으로 가정. k : 경유지
    for i in range(n) : # 거리 행렬을 순회하면서. i : 출발지
        for j in range(n) : # 현재 거리 행렬에 저장된 거리가 k를 거치는 거리보다 멀다면 갱신. j : 목적
            if graph[i][j] > graph[i][k] + graph[k][j] : # 최솟값 갱신. min()보다 빠르다
                graph[i][j] = graph[i][k] + graph[k][j]
            
# 출발점 기준, 어떤 지점 i를 거쳐 각각 a와 b로 가는 최소 비용을 찾는다.
answer = inf
for i in range(n) :
    answer = min(answer, graph[s][i] + graph[i][a] + graph[i][b])

